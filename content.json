{"meta":{"title":"GoodGuy'blog","subtitle":null,"description":"低调做人,低调做事.咸鱼虽寿,犹有竟时.","author":"GoodGuy","url":"http://goodguy.cc"},"pages":[{"title":"关于我","date":"2019-09-29T10:48:20.348Z","updated":"2019-09-29T10:48:11.000Z","comments":true,"path":"about/index.html","permalink":"http://goodguy.cc/about/index.html","excerpt":"","text":""}],"posts":[{"title":"【转载】Android 外置 SD 卡写入权限问题","slug":"text2","date":"2019-10-01T04:24:09.000Z","updated":"2019-10-01T04:29:19.732Z","comments":true,"path":"archives/text2.html","link":"","permalink":"http://goodguy.cc/archives/text2.html","excerpt":"","text":"最近升级到 Android 9.0 后，发现文件管理器在写入外置 SD 卡时出现了写入失败的问题，定位到 File.canWrite() 方法，发现返回了 false。经过讨论追踪定位，发现是由于 Google 的一个更改导致的: diff --git a/data/etc/platform.xml b/data/etc/platform.xml index 04006b1..3021555 100644 --- a/data/etc/platform.xml +++ b/data/etc/platform.xml @@ -62,7 +62,6 @@ &lt;permission name=&quot;android.permission.WRITE_MEDIA_STORAGE&quot; &gt; &lt;group gid=&quot;media_rw&quot; /&gt; - &lt;group gid=&quot;sdcard_rw&quot; /&gt; &lt;/permission&gt; &lt;permission name=&quot;android.permission.ACCESS_MTP&quot; &gt; diff --git a/services/core/java/com/android/server/pm/PackageManagerService.java b/services/core/java/com/android/server/pm/PackageManagerService.java index a0cb722..940d19f 100644 --- a/services/core/java/com/android/server/pm/PackageManagerService.java +++ b/services/core/java/com/android/server/pm/PackageManagerService.java @@ -20936,9 +20936,6 @@ if (Process.isIsolated(uid)) { return Zygote.MOUNT_EXTERNAL_NONE; } - if (checkUidPermission(WRITE_MEDIA_STORAGE, uid) == PERMISSION_GRANTED) { - return Zygote.MOUNT_EXTERNAL_DEFAULT; - } if (checkUidPermission(READ_EXTERNAL_STORAGE, uid) == PERMISSION_DENIED) { return Zygote.MOUNT_EXTERNAL_DEFAULT; } 这里的修改移除了 WRITE_MEDIA_STORAGE 权限相关权限，导致了外部 SD 卡存储不可写的问题。 平台签名应用受影响这个修改对系统应用影响较大，在 9.0 之前的平台，申请了 WRITE_MEDIA_STORAGE 的权限后，平台签名的应用就可以通过 java.io.File 接口写入外置 SD 卡了。但是这个修改之后，想要写入外置 SD 卡，就需要像第三方应用一样，使用 DocumentFile 的接口，可以阅读 API 文档 存储访问框架 和 使用作用域目录访问 。 参考 google 的这个 bug ，平台类的应用，如文件管理器、相机、图库甚至 MediaProvider 都会出现外置 SD 卡只能读不可写，即写入失败的问题，因为这些系统应用都没有适配 DocumentProvider 的写入方式。 DocumentFile 适配方案1. 请求写入外置 SD 卡权限早在 Android 4.4，Android 就已经加入了存储访问框架，外置 SD 卡的访问由 DocumentsUI (com.android.documentsui) 提供支持，经过 5.0 版本的完善以及 7.0 的改进，目前有两种请求外置 SD 卡写入权限的交互方法： Android 7.0 之前，使用 ACTION_OPEN_DOCUMENT_TREE 跳转到 DocumentsUI 的存储选择界面，之后用户手动打开外置存储并选择 手动选择 sd 卡提示 Android 7.0 及之后，使用 StorageVolume.createAccessIntent(null)) 跳转到权限写入提示框。(这个提示框也是 DocumentsUI 提供的，只是对之前的交互做了改进，避免繁琐的用户操作) 新的权限提示框 检查权限界面的属性，会发现这个权限提示框其实是 com.android.documentsui/com.android.documentsui.ScopedAccessActivity 也就是说 DocumentsUI 为了简化权限请求的流程，已经特意做了一个权限的提示框。 而 StorageVolume.createAccessIntent(String directoryName)) 可以传入众多媒体类型，包括音乐、图片、电影、文档等，如果传入参数为 null ，则表示整个外置存储分区。 Parameters directoryName String: must be one of Environment.DIRECTORY_MUSIC, Environment.DIRECTORY_PODCASTS, Environment.DIRECTORY_RINGTONES, Environment.DIRECTORY_ALARMS, Environment.DIRECTORY_NOTIFICATIONS, Environment.DIRECTORY_PICTURES, Environment.DIRECTORY_MOVIES, Environment.DIRECTORY_DOWNLOADS, Environment.DIRECTORY_DCIM, or Environment.DIRECTORY_DOCUMENTS, or null to request access to the entire volume. Returns Intent intent to request access, or null if the requested directory is invalid for that volume. 权限请求及处理 权限请求需要在 Activity 或者 Fragment 中发起，同时在 onActivityResult 中捕获返回的 Uri，这个 Uri 可以保存在本地存储中，方便再次调用。请求的代码封装如下： @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // ... if (DocumentsUtils.checkWritableRootPath(getActivity(), rootPath)) { showOpenDocumentTree(); } // ... } private void showOpenDocumentTree() { Intent intent = null; if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.N) { StorageManager sm = getActivity().getSystemService(StorageManager.class); StorageVolume volume = sm.getStorageVolume(new File(rootPath)); if (volume != null) { intent = volume.createAccessIntent(null); } } if (intent == null) { intent = new Intent(Intent.ACTION_OPEN_DOCUMENT_TREE); } startActivityForResult(intent, DocumentsUtils.OPEN_DOCUMENT_TREE_CODE); } @Override public void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); switch (requestCode) { case DocumentsUtils.OPEN_DOCUMENT_TREE_CODE: if (data != null &amp;&amp; data.getData() != null) { Uri uri = data.getData(); DocumentsUtils.saveTreeUri(getActivity(), rootPath, uri); } break; default: break; } } 这里的 rootPath 是上下文中传入的外置 sd 卡根目录，如 /storage/0000-0000 这样的路径，可以通过 context.getExternalFilesDirs(&quot;external&quot;) 方法获取到。DocumentsUtils 工具类的实现方法见下文。 其中 DocumentsUtils.checkWritableRootPath() 方法用来检查 SD 卡根目录是否有写入权限，如果没有则跳转到权限请求；DocumentsUtils.saveTreeUri() 方法保存返回的 Uri 信息到本地存储，以便之后查询。 2. DocumentFile 文件操作封装由于之前应用使用了 java.io.File 接口操作外置 SD 卡文件，期望对代码的修改量最小，则最好的方式是对已有的 File 操作再做一次封装。 由于 Android 9.0 之前系统应用默认是可以通过 java.io.File 接口写入外置 SD卡 的，而如果作为公开市场第三方应用却在 4.4 之后就不可写，而且有的厂商定制版本 Android 9.0 外置 SD 卡也是可以直接写入而不需要 DocumentFile 接口，DocumentFile 接口也没有 java.io.File 效率高。 所以最好的办法是先检查是否有文件写入权限，如果有写入权限，则直接使用 File 接口操作，如果没有权限再检查文件是否在外置 SD 卡，如果文件在 SD 卡则使用 DocumentFile 接口操作。 封装的工具类 DocumentsUtils 方法说明，不兼容 表示没有封装 DocumentFile 操作： DocumentsUtils 公共方法 功能描述 void cleanCache() 清除路径缓存，建议插拔 sd 卡后调用 boolean isOnExtSdCard(File file, Context c) 文件路径是否在外置 SD 卡上 DocumentFile getDocumentFile(final File file, final boolean isDirectory, Context context) 从 File 转到 DocumentFile boolean mkdirs(Context context, File dir) 创建文件夹 boolean delete(Context context, File file) 删除文件 boolean canWrite(File file) File 文件是否可写（如果文件不存在，则尝试创建文件再删除检查写入权限）不兼容 boolean canWrite(Context context, File file) 文件是否可写 boolean renameTo(Context context, File src, File dest) 文件重命名 boolean saveTreeUri(Context context, String rootPath, Uri uri) 保存 path 和 uri 到本地存储 boolean checkWritableRootPath(Context context, String rootPath) 检查路径是否可写，不可写返回 true InputStream getInputStream(Context context, File destFile) 获取 InputStream，可用于读操作 OutputStream getOutputStream(Context context, File destFile) 获取 OutputStream，可用于写操作 封装的工具类 DocumentsUtils.java 内容如下： public class DocumentsUtils { private static final String TAG = DocumentsUtils.class.getSimpleName(); public static final int OPEN_DOCUMENT_TREE_CODE = 8000; private static List&lt;String&gt; sExtSdCardPaths = new ArrayList&lt;&gt;(); private DocumentsUtils() { } public static void cleanCache() { sExtSdCardPaths.clear(); } /** * Get a list of external SD card paths. (Kitkat or higher.) * * @return A list of external SD card paths. */ @TargetApi(Build.VERSION_CODES.KITKAT) private static String[] getExtSdCardPaths(Context context) { if (sExtSdCardPaths.size() &gt; 0) { return sExtSdCardPaths.toArray(new String[0]); } for (File file : context.getExternalFilesDirs(&quot;external&quot;)) { if (file != null &amp;&amp; !file.equals(context.getExternalFilesDir(&quot;external&quot;))) { int index = file.getAbsolutePath().lastIndexOf(&quot;/Android/data&quot;); if (index &lt; 0) { Log.w(TAG, &quot;Unexpected external file dir: &quot; + file.getAbsolutePath()); } else { String path = file.getAbsolutePath().substring(0, index); try { path = new File(path).getCanonicalPath(); } catch (IOException e) { // Keep non-canonical path. } sExtSdCardPaths.add(path); } } } if (sExtSdCardPaths.isEmpty()) sExtSdCardPaths.add(&quot;/storage/sdcard1&quot;); return sExtSdCardPaths.toArray(new String[0]); } /** * Determine the main folder of the external SD card containing the given file. * * @param file the file. * @return The main folder of the external SD card containing this file, if the file is on an SD * card. Otherwise, * null is returned. */ @TargetApi(Build.VERSION_CODES.KITKAT) private static String getExtSdCardFolder(final File file, Context context) { String[] extSdPaths = getExtSdCardPaths(context); try { for (int i = 0; i &lt; extSdPaths.length; i++) { if (file.getCanonicalPath().startsWith(extSdPaths[i])) { return extSdPaths[i]; } } } catch (IOException e) { return null; } return null; } /** * Determine if a file is on external sd card. (Kitkat or higher.) * * @param file The file. * @return true if on external sd card. */ @TargetApi(Build.VERSION_CODES.KITKAT) public static boolean isOnExtSdCard(final File file, Context c) { return getExtSdCardFolder(file, c) != null; } /** * Get a DocumentFile corresponding to the given file (for writing on ExtSdCard on Android 5). * If the file is not * existing, it is created. * * @param file The file. * @param isDirectory flag indicating if the file should be a directory. * @return The DocumentFile */ public static DocumentFile getDocumentFile(final File file, final boolean isDirectory, Context context) { if (Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.KITKAT) { return DocumentFile.fromFile(file); } String baseFolder = getExtSdCardFolder(file, context); boolean originalDirectory = false; if (baseFolder == null) { return null; } String relativePath = null; try { String fullPath = file.getCanonicalPath(); if (!baseFolder.equals(fullPath)) { relativePath = fullPath.substring(baseFolder.length() + 1); } else { originalDirectory = true; } } catch (IOException e) { return null; } catch (Exception f) { originalDirectory = true; //continue } String as = PreferenceManager.getDefaultSharedPreferences(context).getString(baseFolder, null); Uri treeUri = null; if (as != null) treeUri = Uri.parse(as); if (treeUri == null) { return null; } // start with root of SD card and then parse through document tree. DocumentFile document = DocumentFile.fromTreeUri(context, treeUri); if (originalDirectory) return document; String[] parts = relativePath.split(&quot;/&quot;); for (int i = 0; i &lt; parts.length; i++) { DocumentFile nextDocument = document.findFile(parts[i]); if (nextDocument == null) { if ((i &lt; parts.length - 1) || isDirectory) { nextDocument = document.createDirectory(parts[i]); } else { nextDocument = document.createFile(&quot;image&quot;, parts[i]); } } document = nextDocument; } return document; } public static boolean mkdirs(Context context, File dir) { boolean res = dir.mkdirs(); if (!res) { if (DocumentsUtils.isOnExtSdCard(dir, context)) { DocumentFile documentFile = DocumentsUtils.getDocumentFile(dir, true, context); res = documentFile != null &amp;&amp; documentFile.canWrite(); } } return res; } public static boolean delete(Context context, File file) { boolean ret = file.delete(); if (!ret &amp;&amp; DocumentsUtils.isOnExtSdCard(file, context)) { DocumentFile f = DocumentsUtils.getDocumentFile(file, false, context); if (f != null) { ret = f.delete(); } } return ret; } public static boolean canWrite(File file) { boolean res = file.exists() &amp;&amp; file.canWrite(); if (!res &amp;&amp; !file.exists()) { try { if (!file.isDirectory()) { res = file.createNewFile() &amp;&amp; file.delete(); } else { res = file.mkdirs() &amp;&amp; file.delete(); } } catch (IOException e) { e.printStackTrace(); } } return res; } public static boolean canWrite(Context context, File file) { boolean res = canWrite(file); if (!res &amp;&amp; DocumentsUtils.isOnExtSdCard(file, context)) { DocumentFile documentFile = DocumentsUtils.getDocumentFile(file, true, context); res = documentFile != null &amp;&amp; documentFile.canWrite(); } return res; } public static boolean renameTo(Context context, File src, File dest) { boolean res = src.renameTo(dest); if (!res &amp;&amp; isOnExtSdCard(dest, context)) { DocumentFile srcDoc; if (isOnExtSdCard(src, context)) { srcDoc = getDocumentFile(src, false, context); } else { srcDoc = DocumentFile.fromFile(src); } DocumentFile destDoc = getDocumentFile(dest.getParentFile(), true, context); if (srcDoc != null &amp;&amp; destDoc != null) { try { if (src.getParent().equals(dest.getParent())) { res = srcDoc.renameTo(dest.getName()); } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { res = DocumentsContract.moveDocument(context.getContentResolver(), srcDoc.getUri(), srcDoc.getParentFile().getUri(), destDoc.getUri()) != null; } } catch (Exception e) { e.printStackTrace(); } } } return res; } public static InputStream getInputStream(Context context, File destFile) { InputStream in = null; try { if (!canWrite(destFile) &amp;&amp; isOnExtSdCard(destFile, context)) { DocumentFile file = DocumentsUtils.getDocumentFile(destFile, false, context); if (file != null &amp;&amp; file.canWrite()) { in = context.getContentResolver().openInputStream(file.getUri()); } } else { in = new FileInputStream(destFile); } } catch (FileNotFoundException e) { e.printStackTrace(); } return in; } public static OutputStream getOutputStream(Context context, File destFile) { OutputStream out = null; try { if (!canWrite(destFile) &amp;&amp; isOnExtSdCard(destFile, context)) { DocumentFile file = DocumentsUtils.getDocumentFile(destFile, false, context); if (file != null &amp;&amp; file.canWrite()) { out = context.getContentResolver().openOutputStream(file.getUri()); } } else { out = new FileOutputStream(destFile); } } catch (FileNotFoundException e) { e.printStackTrace(); } return out; } public static boolean saveTreeUri(Context context, String rootPath, Uri uri) { DocumentFile file = DocumentFile.fromTreeUri(context, uri); if (file != null &amp;&amp; file.canWrite()) { SharedPreferences perf = PreferenceManager.getDefaultSharedPreferences(context); perf.edit().putString(rootPath, uri.toString()).apply(); return true; } else { Log.e(TAG, &quot;no write permission: &quot; + rootPath); } return false; } public static boolean checkWritableRootPath(Context context, String rootPath) { File root = new File(rootPath); if (!root.canWrite()) { if (DocumentsUtils.isOnExtSdCard(root, context)) { DocumentFile documentFile = DocumentsUtils.getDocumentFile(root, true, context); return documentFile == null || !documentFile.canWrite(); } else { SharedPreferences perf = PreferenceManager.getDefaultSharedPreferences(context); String documentUri = perf.getString(rootPath, &quot;&quot;); if (documentUri == null || documentUri.isEmpty()) { return true; } else { DocumentFile file = DocumentFile.fromTreeUri(context, Uri.parse(documentUri)); return !(file != null &amp;&amp; file.canWrite()); } } } return false; } } 参考Media process should run with “write” access. [Developer Preview Android P]WRITE_MEDIA_STORAGE is not working for system apps to access the secondary storage. AmazeFileManager/FileUtil.java 原文：https://busy.im/post/android-sdcard-write/","categories":[],"tags":[]},{"title":"【转载】ANDROID中调用文件管理器并返回选中文件的路径","slug":"text1","date":"2019-09-29T10:58:15.000Z","updated":"2019-09-29T11:26:18.924Z","comments":true,"path":"archives/text1.html","link":"","permalink":"http://goodguy.cc/archives/text1.html","excerpt":"","text":"实际项目中经常需要调用文件管理器，选择下载路径或者上传的本地文件路径。今天就给大家做个demo示范该功能的实现过程。 一、实现效果预览以下为三星S6的样机测试效果，当然不同手机调用后的效果不一样。 二、代码实现布局文件很简单，就一个Button和TextView，这里不示范了，直接上实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193package com.panhouye.selectfile;import android.annotation.SuppressLint;import android.app.Activity;import android.content.ContentUris;import android.content.Context;import android.content.Intent;import android.database.Cursor;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.os.Environment;import android.provider.DocumentsContract;import android.provider.MediaStore;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; TextView tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btn = (Button) findViewById(R.id.btn); tv = (TextView) findViewById(R.id.tv); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_GET_CONTENT); //intent.setType(“image/*”);//选择图片 //intent.setType(“audio/*”); //选择音频 //intent.setType(“video/*”); //选择视频 （mp4 3gp 是android支持的视频格式） //intent.setType(“video/*;image/*”);//同时选择视频和图片 intent.setType(&quot;*/*&quot;);//无类型限制 intent.addCategory(Intent.CATEGORY_OPENABLE); startActivityForResult(intent, 1); &#125; &#125;); &#125; String path; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (resultCode == Activity.RESULT_OK) &#123; Uri uri = data.getData(); if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme()))&#123;//使用第三方应用打开 path = uri.getPath(); tv.setText(path); Toast.makeText(this,path+&quot;11111&quot;,Toast.LENGTH_SHORT).show(); return; &#125; if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.KITKAT) &#123;//4.4以后 path = getPath(this, uri); tv.setText(path); Toast.makeText(this,path,Toast.LENGTH_SHORT).show(); &#125; else &#123;//4.4以下下系统调用方法 path = getRealPathFromURI(uri); tv.setText(path); Toast.makeText(MainActivity.this, path+&quot;222222&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; public String getRealPathFromURI(Uri contentUri) &#123; String res = null; String[] proj = &#123; MediaStore.Images.Media.DATA &#125;; Cursor cursor = getContentResolver().query(contentUri, proj, null, null, null); if(null!=cursor&amp;&amp;cursor.moveToFirst())&#123;; int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA); res = cursor.getString(column_index); cursor.close(); &#125; return res; &#125; /** * 专为Android4.4设计的从Uri获取文件绝对路径，以前的方法已不好使 */ @SuppressLint(&quot;NewApi&quot;) public String getPath(final Context context, final Uri uri) &#123; final boolean isKitKat = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT; // DocumentProvider if (isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) &#123; // ExternalStorageProvider if (isExternalStorageDocument(uri)) &#123; final String docId = DocumentsContract.getDocumentId(uri); final String[] split = docId.split(&quot;:&quot;); final String type = split[0]; if (&quot;primary&quot;.equalsIgnoreCase(type)) &#123; return Environment.getExternalStorageDirectory() + &quot;/&quot; + split[1]; &#125; &#125; // DownloadsProvider else if (isDownloadsDocument(uri)) &#123; final String id = DocumentsContract.getDocumentId(uri); final Uri contentUri = ContentUris.withAppendedId( Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(id)); return getDataColumn(context, contentUri, null, null); &#125; // MediaProvider else if (isMediaDocument(uri)) &#123; final String docId = DocumentsContract.getDocumentId(uri); final String[] split = docId.split(&quot;:&quot;); final String type = split[0]; Uri contentUri = null; if (&quot;image&quot;.equals(type)) &#123; contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; &#125; else if (&quot;video&quot;.equals(type)) &#123; contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI; &#125; else if (&quot;audio&quot;.equals(type)) &#123; contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI; &#125; final String selection = &quot;_id=?&quot;; final String[] selectionArgs = new String[]&#123;split[1]&#125;; return getDataColumn(context, contentUri, selection, selectionArgs); &#125; &#125; // MediaStore (and general) else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) &#123; return getDataColumn(context, uri, null, null); &#125; // File else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) &#123; return uri.getPath(); &#125; return null; &#125; /** * Get the value of the data column for this Uri. This is useful for * MediaStore Uris, and other file-based ContentProviders. * * @param context The context. * @param uri The Uri to query. * @param selection (Optional) Filter used in the query. * @param selectionArgs (Optional) Selection arguments used in the query. * @return The value of the _data column, which is typically a file path. */ public String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) &#123; Cursor cursor = null; final String column = &quot;_data&quot;; final String[] projection = &#123;column&#125;; try &#123; cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null); if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123; final int column_index = cursor.getColumnIndexOrThrow(column); return cursor.getString(column_index); &#125; &#125; finally &#123; if (cursor != null) cursor.close(); &#125; return null; &#125; /** * @param uri The Uri to check. * @return Whether the Uri authority is ExternalStorageProvider. */ public boolean isExternalStorageDocument(Uri uri) &#123; return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority()); &#125; /** * @param uri The Uri to check. * @return Whether the Uri authority is DownloadsProvider. */ public boolean isDownloadsDocument(Uri uri) &#123; return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority()); &#125; /** * @param uri The Uri to check. * @return Whether the Uri authority is MediaProvider. */ public boolean isMediaDocument(Uri uri) &#123; return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority()); &#125;&#125; 三、小结这是调用系统自带的文件管理，无法保证和控制统一的界面显示，所以大家还是要实现与自己APP统一的文件管理界面，共勉。 原文地址：http://www.cnblogs.com/panhouye/archive/2017/04/23/6751710.html","categories":[],"tags":[]},{"title":"六百块钱买的松人显示器质量如何","slug":"evaluation1","date":"2018-05-02T04:31:00.000Z","updated":"2019-09-30T14:51:21.233Z","comments":true,"path":"archives/evaluation1.html","link":"","permalink":"http://goodguy.cc/archives/evaluation1.html","excerpt":"","text":"前言 9ujrNj.md.jpg 一般IPS显示器24寸都要1000+ 松人作为国产中的山寨战斗机一直有莫名的性价比 于是上了一波车 开箱 9uj6Cn.md.jpg 这玩意还有赠品… 9uj0Hg.md.jpg 内部还是相当简陋的 开机 乍一看上去好像还可以，是完美屏 9ujc3q.md.jpg 但是好像还是有点灰蒙蒙的（其实是英伟达显卡驱动识别默认以有限灰阶输出的锅，调整一下就好很多） 关键问题 9uj2vV.md.jpg 很明显的做工问题低端ips没想到还是有很明显的拖影 9ujgg0.md.jpg 拖影问题相当影响游戏观感，不过在亮色环境下不明显 9ujWuT.md.jpg 实际上拖影是因为灰阶响应较慢的问题(va软屏面板尤为严重），某船笔记本也有这类问题（程度较轻一些） 9ujDEQ.md.jpg 简陋的OSD 9ujIUJ.md.jpg 后记：之后我退换了一款松人999人民币165hz的25寸1080p，拖影算是没有了，不过面板不是完美屏了，有一个亮点（边缘不算太影响，补贴30r），依旧做有工问题。有钱还是买好一些的显示器吧-。 -","categories":[],"tags":[]},{"title":"神舟Z8-SP7D1拆机换网卡以及硅脂","slug":"skill3","date":"2017-11-15T14:03:00.000Z","updated":"2019-09-30T14:52:16.582Z","comments":true,"path":"archives/skill3.html","link":"","permalink":"http://goodguy.cc/archives/skill3.html","excerpt":"","text":"前言 神舟Z8-SP7D1是蓝天的P650RS模具 散热模块采用三风扇+5热管的组合，但是由于较薄，散热一般 神舟一贯作风便是缩水网卡屏幕，以及原厂硅脂涂抹比较玄学（瞎涂） 吐槽：z8采用的无线网卡是M2接口的英特尔3165AC网卡，自带蓝牙4.0，支持双频但是信号质量一般而且最高速度只有433Mbps，天线实际利用是1x1(因此虽然有俩天线但有一根天线是备用摆设)。 换网卡：网卡由于是NGFF/M2接口，所以说换起来还是很容易，大多数的M2接口的网卡都可以换，本文以8265AC为例。（安装前最好先卸载旧网卡驱动） 打开后盖后找到网卡位置 6x7Os.md.png 拔出天线和旧网卡（有点紧） 6xbmn.md.png 6xqwq.md.png 原样安装即可（安装好天线，注意1 2接口不要安错） 6xTyj.md.png 换硅脂：GTX1070发热大户，神舟装配工人居然有一大半几乎没抹上硅脂，怪不得直逼90++。 6xfFf.md.jpg cpu原厂硅脂还好 6xhY8.md.jpg 散热模具（拆卸顺序按照散热模具上标识的数字即可） 6x4fS.md.jpg 清理后重新抹上7783导热硅脂 6xolQ.md.jpg 完成细节（这里必须先拆卸这个横梁） 6zepD.md.jpg","categories":[],"tags":[]},{"title":"如何不使用第三方的情况下解决bilibili客户端离线下载新番版权受限问题","slug":"skill2","date":"2017-10-14T14:03:00.000Z","updated":"2019-09-30T14:51:53.783Z","comments":true,"path":"archives/skill2.html","link":"","permalink":"http://goodguy.cc/archives/skill2.html","excerpt":"","text":"前言 哔哩哔哩（B站）是众所周知的 ACG 二刺螈 网站 由于大版权时代的来临，连部分有版权的新番也无法离线下载 在这里写出如何不使用第三方插件或解析软件的前提下进行离线 原理：利用不同地区的版权限制使用VPN或SS代理获得离线权 优点： 不需要第三方插件或解析软件，直接通过B站官方客户端下载 与此同时bilime之类的解析软件长时间不更新而失效 开启VPN加入到下载列表后可以退出代理继续满速下载 方法：挂代理之前： 8PNOs.md.jpg 这个时候打开代理（如赛风或者SSR SS）使用荷兰或者俄罗斯节点 8PYlQ.md.jpg 然后重新打开哔哩哔哩客户端，发现已经可以下载 8Pamn.md.jpg 添加进入下载列表，退出代理继续下载即可 8Ptyj.md.jpg 特别注意：必须使用荷兰或者俄罗斯节点（其他如美国日本节点不行），当然部分其他国家节点也许可以 附加：此方法截止2017.10.14有效，不保证以后依然有效，对于绝大部分限制离线版权番都一样有效","categories":[],"tags":[]},{"title":"记一次 魅族路由器极速版 刷Padavan固件经历","slug":"skill1","date":"2017-09-30T14:03:00.000Z","updated":"2019-09-30T14:49:39.485Z","comments":true,"path":"archives/skill1.html","link":"","permalink":"http://goodguy.cc/archives/skill1.html","excerpt":"","text":"前言 魅族路由器不同于小米路由器或是极路由以及newifi之类的热门路由。 网络上关于魅族路由器极速版的刷机教程凤毛麟角，可以说是几乎没有。 前不久好不容易找到关于魅族路由器极速版刷Padavan的方法，于是乎记录下来。 所需文件地址：Padavan固件：https://coding.net/u/c0ding/p/p4davan-fw/git/raw/master/down/rom/MZ-R18/MZ-R18_3.4.3.9-099.trx其他（tftp32以及原厂固件）：https://pan.baidu.com/s/1c2lMfRE 关于Padavang固件 由华硕固件魔改而成，俗称老毛子固件。 操作界面繁琐，功能丰富。 集成了部分特殊插件。 刷机方法 1 1、最好将杀毒软件关掉，有时候tftp32.exe程序可能会被杀毒软件误杀2、如果是win7或以上的系统，工具和固件最好不要放在C盘，防止被UAC等防火墙禁掉3、请确保电脑网卡设置成了10.10.10.3的地址，以前有用户误将宽带拨号的网络标示当成网卡来设置了4、上电后松开按钮的时间不能太晚也不能太早，太晚或太早都会导致TFTP无反应，升级不成功 特别注意：进入救援模式（刷机模式）时务必记住先断开电源（拔掉电源线），之后按住wps按键不放，然后接通电源线，等待4-7秒后松手。 在TFTP出现路由请求接收固件文件成功后，等待3分钟以上，重启路由器即可。成功后可以登录192.168.99.1（一般是）进入web管理，默认管理账户admin密码admin，wifi密码1234567890。看见如下界面说明成功。 2 后记：魅族路由器可玩性并不高，不打折的情况下不推荐购买。虽然如此，依然有人适配（虽然不知道是不是只是随便改改）固件，也许在网上多试一试其他该解决方案的通用固件刷一刷（作死）也未尝不可。","categories":[],"tags":[]},{"title":"【工具推荐】 RPG Maker MV","slug":"tool3","date":"2017-09-23T14:03:00.000Z","updated":"2019-09-30T14:53:00.352Z","comments":true,"path":"archives/tool3.html","link":"","permalink":"http://goodguy.cc/archives/tool3.html","excerpt":"","text":"简介 RPG Maker MV 是专为制作角色扮演游戏而生的制作工具。本作的游戏将输出为 HTML5 格式，使用这一格式，完成的游戏将可以发布在 Windows、Mac OS X、安卓、iOS平台，甚至作为网页游戏在线发布。汉化中文帮助文档 http://help.rpgmakermv.cn/ 1 RPG Maker 系列前作有 RPG Maker 2000，RPG Maker 2003，RPG Maker XP，RPG Maker VX，RPG Maker VX Ace RPG Maker MV和系列前作相比，《RPG制作大师MV》将是系列史上功能最强大的一作，新作包含下列特性——传统的脚本编辑器已经移除，取而代之的将是一个更简单的脚本管理工具，使用简单的JavaScript。实现了原来的第三方脚本特性的原生化集成，游戏运行效率也大大提升。数据库内容的最大值增加，道具上限大幅提升，技能、物品、武器、防具、敌人和敌群数据最多都可达到2000条；数据库脚本数据编辑更加方便。本作的游戏将输出为 HTML5 格式。使用这一格式，完成的游戏能发布在 Windows、Mac OS X、安卓、iOS平台，甚至作为网页游戏在线发布。允许通过拉伸窗口调整游戏画面的大小；游戏运行分辨率高由544×416提升至816×624，图块大小由32扩大到48，画质大幅提升。事件选项的最大个数从4个增加到了6个，允许设置选项窗口的位置和不透明度；新增事件搜索工具，优化事件编辑器。保留前作纵版战斗的基础上新增横版战斗模式，同时优化战斗细节。自动三层级地图；地图区域数量上限扩大到255。 更加丰富（？）的内置素材（DLC？）游戏初始菜单新增游戏设置指令。新增声场控制，音效控制优化。同时支持触控和鼠标操作。纸娃娃生成器优化。…… 以上都出自于百度百科以及帮助文档 特点 1 优点： 不需要编程基础，但是会编程能如虎添翼（插件采用javascript编写） 丰富多彩的插件系统 编写效率远高于一般引擎 UI界面对萌新非常友好 支持多平台！！ 缺点： 编译后的安装包臃肿 自由度比一般引擎低，对于联机等功能乏力 受到业界dalao歧视 为什么购买它RPG Maker MV 于 steam 上架，本体原价 204 RMB ，G胖打折 off-70% = 买买买！！ RPG Maker MV比不上Unity3d，但也绝非橙光游戏之流，虽然人气低迷（66RPG也要关了），但他依旧能圆你的游戏梦。 1","categories":[],"tags":[]},{"title":"【工具推荐】 神经卷积网络图片放大-waifu2x","slug":"tool2","date":"2017-09-07T14:03:00.000Z","updated":"2019-09-30T14:52:39.222Z","comments":true,"path":"archives/tool2.html","link":"","permalink":"http://goodguy.cc/archives/tool2.html","excerpt":"","text":"简介使用卷积神经网络对动漫风格的图片进行放大操作（支持照片），是一套自带像素填充与降噪的算法。 目前拥有多个版本在线网页版本：http://waifu2x.udp.jp/Git站caffe版本源码：https://github.com/lltcggie/waifu2x-caffe waifu2x同时支持CUAD cuDNN 和CPU多个模式 影响目前二次元界最好用的图片黑科技之一，可以结合VapouSynth优雅地调用Waifu2x处理视频（被国内某知名字幕组如 魔穗 采用） 1 1","categories":[],"tags":[]},{"title":"【工具推荐】 音视频压制处理软件-小丸工具箱","slug":"tool1","date":"2017-09-07T12:54:00.000Z","updated":"2019-09-30T14:53:23.221Z","comments":true,"path":"archives/tool1.html","link":"","permalink":"http://goodguy.cc/archives/tool1.html","excerpt":"","text":"简介小丸工具箱是一款用于处理音视频等多媒体文件的软件。是一款x264、ffmpeg等命令行程序的图形界面。它的目标是让视频压制变得简单、轻松。 主要功能高质量的H264+AAC视频压制（同时也支持实验性的h265编码）ASS/SRT字幕内嵌到视频AAC/WAV/FLAC/ALAC音频转换MP4/MKV/FLV的无损抽取和封装官网：http://maruko.appinn.me/","categories":[],"tags":[]}]}